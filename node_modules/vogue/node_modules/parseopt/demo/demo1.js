const OptionParser = require('./../parseopt').OptionParser;

var parser = new OptionParser({
	minargs: 1,
	maxargs: 10,
	strings: { help: 'N/A', metavars: { integer: 'INT' } },
	options: [
		{
			names: ['--help', '-h'],
			type: 'flag',
			help: 'Show this help message.',
			onOption: function (value) {
				if (value) {
					parser.usage('This is a help text. (Could also be credits etc.)');
				}
				// returning true canceles any further option parsing
				// and parser.parse() returns null
				return value;
			}
		}
	]
});

// other way to define options:
parser.add(['--foo', '-f'], {
	type: 'flag',
	help: 'This is a flag.',
	details: ['bla','blub']
});

parser.add('--bar', {
	type: 'flag',
	value: false,
	target: 'foo',
	help: 'This is the inverse of --foo.'
});

parser.add('-s');
parser.add('--s2', {default: 'blub'});
parser.add('-i', {type: 'int', required: true, redefinable: false});
parser.add('--int32', {type: 'integer',
	min: -2147483648, max: 2147483647, metavar: 'INT32'});
parser.add('--hex', {type: 'integer', base: 16});
parser.add(['-n','-d','--float'], {type: 'float', NaN: true});
parser.add('-o', {type: 'object', default: {foo: 'bar', egg: null, spam: true}});
parser.add('-b', {type: 'boolean', default: true});
parser.add('-x', {type: 'flag', redefinable: false});
parser.add('--r1', {type: 'integer', default: 1, min: 0, base: 8});
parser.add('--r2', {type: 'integer', default: 3, max: 20, base: 16});
parser.add('--r3', {type: 'integer', default: 4, min: -10, max: 10, base: 2});
parser.add('--egg', {type: 'option', default: 'none'});
parser.add('--spam', {type: 'option', target: 'egg'});
parser.add('--tomato', {type: 'option', target: 'egg', value: 'bla'});
parser.add('--sel1', {type: 'enum', values: {foo: 42, bar: 23}});
parser.add('--sel2', {type: 'enum', values: ['egg', 'spam spam'], default: ' '});
parser.add('--foo-bar', {default: 'bla "bla" \t\n \'bla\' \\'});
parser.add('--EGG--SPAM');
parser.add('--b64', {type: 'custom', argc: 1, metavar: 'BASE64-STRING',
	parse: function (s) { return new Buffer(s, 'base64'); },
	stringify: function (buffer) { return buffer.toString('base64'); },
	help: 'Pass binary data as a base64 encoded string.'});
parser.add('-t', {type: 'record',
	default: [11., 5, 'foo'],
	args: [
		{type: 'float'},
		{type: 'integer', min: 1, max: 22},
		{type: 'string'}
	]});
parser.add(['--record','-T'], {type: 'record',
	default: ['bla', [10, 'bleh']],
	args: [
		{type: 'string'},
		{type: 'record', args: [
			{type: 'integer'},
			{type: 'string'}
		]}
	],
	onOption: function (str, rec) {
		console.log('args: '+JSON.stringify(str)+', '+JSON.stringify(rec));
	}});
parser.add('--named', {type: 'record',
	create: Object,
	default: {a: 0.5, b: 300, c: 'bla'},
	args: [
		{type: 'float',   target: 'a'},
		{type: 'integer', target: 'b'},
		{type: 'string',  target: 'c'}
	]});

var data = parser.parse();

if (data) {
	console.log('Options:');
	var displayed = {};
	for (var name in parser.options) {
		var opt = parser.options[name];
		if (!(opt.target in displayed)) {
			var value = data.options[opt.target];
			console.log('\t'+opt.target+': '+ (value === undefined ?
				value : opt.stringify(value)));
			displayed[opt.target] = true;
		}
	}
	console.log(''); 
	console.log('Arguments:');
	for (var i in data.arguments) {
		console.log('\t'+data.arguments[i]);
	}
}
